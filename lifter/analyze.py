from binaryninja import InstructionTextToken, InstructionTextTokenType
from .instructions.mov import *
from .instructions.incdec import *
from .instructions.addsub import *
from .instructions.bitwise import *
from .instructions.branches import *
from .instructions.loadstore import *
from .instructions.stack import *
from .instructions.other import *



# I think if I were cool, I could make the instructions decode
# their register values and stuff themselves - but this 'should'
# work for the time being
opdict = {
    0x00 : (NOP, None),
    0x01 : (LoadRegImm, ['BC']),
    0x02 : (StoreMemA, ['BC']),
    0x03 : (IncReg16, ['B']),
    0x04 : (IncReg, ['B']),
    0x05 : (DecReg, ['B']),
    0x06 : (MovRegImm, ['B']),
    0x07 : (RotateAccumulatorLeftWithCarry, None),
    0x09 : (AddHLReg, ['BC']),
    0x0a : (LoadAccumulatorRegMem, ['BC']),
    0x0b : (DecReg16, ['BC']),
    0x0c : (IncReg, ['C']),
    0x0d : (DecReg, ['C']),
    0x0e : (MovRegImm, ['C']),
    0x0f : (RotateAccumulatorRightWithCarry, None),
    0x11 : (LoadRegImm, ['DE']),
    0x12 : (StoreMemA, ['DE']),
    0x13 : (IncReg16, ['DE']),
    0x14 : (IncReg, ['D']),
    0x15 : (DecReg, ['D']),
    0x16 : (MovRegImm, ['D']),
    0x17 : (RotateAccumulatorLeft, None),
    0x19 : (AddHLReg, ['DE']),
    0x1a : (LoadAccumulatorRegMem, ['DE']),
    0x1b : (DecReg16, ['DE']),
    0x1c : (IncReg, ['E']),
    0x1d : (DecReg, ['E']),
    0x1e : (MovRegImm, ['E']),
    0x1f : (RotateAccumulatorRight, None),
    0x20 : (NOP, None), # Shouldn't be implemented? getting key error here
    0x21 : (LoadRegImm, ['HL']),
    0x22 : (StoreMemReg, []),
    0x23 : (IncReg16, ['HL']),
    0x24 : (IncReg, ['H']),
    0x25 : (DecReg, ['H']),
    0x26 : (MovRegImm, ['H']),
    0x27 : (DAA, None),
    0x29 : (AddHLReg, ['HL']),
    0x2a : (LoadMemReg, []),
    0x2b : (DecReg16, ['HL']),
    0x2c : (IncReg, ['L']),
    0x2d : (DecReg, ['L']),
    0x2e : (MovRegImm, ['L']),
    0x2f : (NotAccumulator, None),
    0x31 : (LoadRegImm, ['SP']),
    0x32 : (StoreAddrA, []),
    0x33 : (IncReg16, ['SP']),
    0x34 : (IncMem, None),
    0x35 : (DecMem, None),
    0x36 : (MovMemImm, []),
    0x37 : (SetCarry, None),
    0x39 : (AddHLReg, ['SP']),
    0x3a : (LoadAccumulatorMem, []),
    0x3b : (DecReg16, ['SP']),
    0x3c : (IncReg, ['A']),
    0x3d : (DecReg, ['A']),
    0x3e : (MovRegImm, ['A']),
    0x3f : (NotCarry, None),
    0x40 : (MovRegReg, ['B', 'B']), # NOP?
    0x41 : (MovRegReg, ['B', 'C']),
    0x42 : (MovRegReg, ['B', 'D']),
    0x43 : (MovRegReg, ['B', 'E']),
    0x44 : (MovRegReg, ['B', 'H']),
    0x45 : (MovRegReg, ['B', 'L']),
    0x46 : (MovRegMem, ['B']),
    0x47 : (MovRegReg, ['B', 'A']),
    0x48 : (MovRegReg, ['C', 'B']),
    0x49 : (MovRegReg, ['C', 'C']), # NOP?
    0x4a : (MovRegReg, ['C', 'D']),
    0x4b : (MovRegReg, ['C', 'E']),
    0x4c : (MovRegReg, ['C', 'H']),
    0x4d : (MovRegReg, ['C', 'L']),
    0x4e : (MovRegMem, ['C']),
    0x4f : (MovRegReg, ['C', 'A']),
    0x50 : (MovRegReg, ['D', 'B']),
    0x51 : (MovRegReg, ['D', 'C']),
    0x52 : (MovRegReg, ['D', 'D']), # NOP?
    0x53 : (MovRegReg, ['D', 'E']),
    0x54 : (MovRegReg, ['D', 'H']),
    0x55 : (MovRegReg, ['D', 'L']),
    0x56 : (MovRegMem, ['D']),
    0x57 : (MovRegReg, ['D', 'A']),
    0x58 : (MovRegReg, ['E', 'B']),
    0x59 : (MovRegReg, ['E', 'C']),
    0x5a : (MovRegReg, ['E', 'D']),
    0x5b : (MovRegReg, ['E', 'E']), # NOP?
    0x5c : (MovRegReg, ['E', 'H']),
    0x5d : (MovRegReg, ['E', 'L']),
    0x5e : (MovRegMem, ['E']),
    0x5f : (MovRegReg, ['E', 'A']),
    0x60 : (MovRegReg, ['H', 'B']),
    0x61 : (MovRegReg, ['H', 'C']),
    0x62 : (MovRegReg, ['H', 'D']),
    0x63 : (MovRegReg, ['H', 'E']),
    0x64 : (MovRegReg, ['H', 'H']), # NOP?
    0x65 : (MovRegReg, ['H', 'L']),
    0x66 : (MovRegMem, ['H']),
    0x67 : (MovRegReg, ['H', 'A']),
    0x68 : (MovRegReg, ['L', 'B']),
    0x69 : (MovRegReg, ['L', 'C']),
    0x6a : (MovRegReg, ['L', 'D']),
    0x6b : (MovRegReg, ['L', 'E']),
    0x6c : (MovRegReg, ['L', 'H']),
    0x6d : (MovRegReg, ['L', 'L']), # NOP?
    0x6e : (MovRegMem, ['L']),
    0x6f : (MovRegReg, ['L', 'A']),
    0x70 : (MovMemReg, ['B']),
    0x71 : (MovMemReg, ['C']),
    0x72 : (MovMemReg, ['D']),
    0x73 : (MovMemReg, ['E']),
    0x74 : (MovMemReg, ['H']),
    0x75 : (MovMemReg, ['L']),
    0x76 : (HLT, None),
    0x77 : (MovMemReg, ['A']),
    0x78 : (MovRegReg, ['A', 'B']),
    0x79 : (MovRegReg, ['A', 'C']),
    0x7a : (MovRegReg, ['A', 'D']),
    0x7b : (MovRegReg, ['A', 'E']),
    0x7c : (MovRegReg, ['A', 'H']),
    0x7d : (MovRegReg, ['A', 'L']),
    0x7e : (MovRegMem, ['A']),
    0x7f : (MovRegReg, ['A', 'A']), # NOP?
    0x80 : (AddReg, ['B']),
    0x81 : (AddReg, ['C']),
    0x82 : (AddReg, ['D']),
    0x83 : (AddReg, ['E']),
    0x84 : (AddReg, ['H']),
    0x85 : (AddReg, ['L']),
    0x86 : (AddMem, None),
    0x87 : (AddReg, ['A']),
    0x88 : (AddRegWithCarry, ['B']),
    0x89 : (AddRegWithCarry, ['C']),
    0x8a : (AddRegWithCarry, ['D']),
    0x8b : (AddRegWithCarry, ['E']),
    0x8c : (AddRegWithCarry, ['H']),
    0x8d : (AddRegWithCarry, ['L']),
    0x8e : (AddMemWithCarry, None),
    0x8f : (AddRegWithCarry, ['A']),
    0x90 : (SubReg, ['B']),
    0x91 : (SubReg, ['C']),
    0x92 : (SubReg, ['D']),
    0x93 : (SubReg, ['E']),
    0x94 : (SubReg, ['H']),
    0x95 : (SubReg, ['L']),
    0x96 : (SubMem, None),
    0x97 : (SubReg, ['A']),
    0x98 : (SubRegWithCarry, ['B']),
    0x99 : (SubRegWithCarry, ['C']),
    0x9a : (SubRegWithCarry, ['D']),
    0x9b : (SubRegWithCarry, ['E']),
    0x9c : (SubRegWithCarry, ['H']),
    0x9d : (SubRegWithCarry, ['L']),
    0x9e : (SubMemWithCarry, None),
    0x9f : (SubRegWithCarry, ['A']),
    0xa0 : (AndAccumulatorReg, ['B']),
    0xa1 : (AndAccumulatorReg, ['C']),
    0xa2 : (AndAccumulatorReg, ['D']),
    0xa3 : (AndAccumulatorReg, ['E']),
    0xa4 : (AndAccumulatorReg, ['H']),
    0xa5 : (AndAccumulatorReg, ['L']),
    0xa6 : (AndAccumulatorMem, None),
    0xa7 : (AndAccumulatorReg, ['A']),
    0xa8 : (XorAccumulatorReg, ['B']),
    0xa9 : (XorAccumulatorReg, ['C']),
    0xaa : (XorAccumulatorReg, ['D']),
    0xab : (XorAccumulatorReg, ['E']),
    0xac : (XorAccumulatorReg, ['H']),
    0xad : (XorAccumulatorReg, ['L']),
    0xae : (XorAccumulatorMem, None),
    0xaf : (XorAccumulatorReg, ['A']),
    0xb0 : (OrAccumulatorReg, ['B']),
    0xb1 : (OrAccumulatorReg, ['C']),
    0xb2 : (OrAccumulatorReg, ['D']),
    0xb3 : (OrAccumulatorReg, ['E']),
    0xb4 : (OrAccumulatorReg, ['H']),
    0xb5 : (OrAccumulatorReg, ['L']),
    0xb6 : (OrAccumulatorMem, None),
    0xb7 : (OrAccumulatorReg, ['A']),
    0xb8 : (CompareReg, ['B']),
    0xb9 : (CompareReg, ['C']),
    0xba : (CompareReg, ['D']),
    0xbb : (CompareReg, ['E']),
    0xbc : (CompareReg, ['H']),
    0xbd : (CompareReg, ['L']),
    0xbe : (CompareMem, None),
    0xbf : (CompareReg, ['A']),
    0xc0 : (ReturnNotZero, None),
    0xc1 : (PopReg, ['BC']),
    0xc2 : (JumpNotZero, []),
    0xc3 : (UnconditionalJump, []),
    0xc4 : (CallNotZero, []),
    0xc5 : (PushReg, ['BC']),
    0xc6 : (AddImm, []),
    0xc7 : (Reset, ['0']),
    0xc8 : (ReturnZero, None),
    0xc9 : (UnconditionalReturn, None),
    0xca : (JumpZero, []),
    0xcc : (CallZero, []),
    0xcd : (UnconditionalCall, []),
    0xce : (AddImmWithCarry, []),
    0xcf : (Reset, ['1']),
    0xd0 : (ReturnNotCarry, None),
    0xd1 : (PopReg, ['DE']),
    0xd2 : (JumpNotCarry, []),
    0xd3 : (OUT, []),
    0xd4 : (CallNotCarry, []),
    0xd5 : (PushReg, ['DE']),
    0xd6 : (SubImm, []),
    0xd7 : (Reset, ['2']),
    0xd8 : (ReturnCarry, None),
    0xda : (JumpCarry, []),
    0xdb : (IN, []),
    0xdc : (CallCarry, []),
    0xde : (SubImmWithCarry, []),
    0xdf : (Reset, ['3']),
    0xe0 : (ReturnParityOdd, None),
    0xe1 : (PopReg, ['HL']),
    0xe2 : (JumpParityOdd, []),
    0xe3 : (MovToHL, None),
    0xe4 : (CallParityOdd, []),
    0xe5 : (PushReg, ['HL']),
    0xe6 : (AndAccumulatorImm, []),
    0xe7 : (Reset, ['4']),
    0xe8 : (ReturnParityEven, None),
    0xe9 : (HLToPC, None),
    0xea : (JumpParityEven, []),
    0xeb : (Exchange, None),
    0xec : (CallParityEven, []),
    0xee : (XorAccumulatorImm, []),
    0xef : (Reset, ['5']),
    0xf0 : (ReturnPositive, None),
    0xf1 : (PopAFlags, None),
    0xf2 : (JumpPositive, []),
    0xf3 : (DI, None),
    0xf4 : (CallPositive, []),
    0xf5 : (PushAFlags, None),
    0xf6 : (OrAccumulatorImm, []),
    0xf7 : (Reset, ['6']),
    0xf8 : (ReturnMinus, None),
    0xf9 : (HLToSP, None),
    0xfa : (JumpMinus, []),
    0xfb : (EI, None),
    0xfc : (CallMinus, []),
    0xfe : (CompareImm, []),
    0xff : (Reset, ['7']),
    0xfd : (NOP, None),
    0xed : (NOP, None),
    0x08 : (NOP, None),
    0x10 : (NOP, None),
    0xdd : (NOP, None),
    0xd9 : (NOP, None),
    0xcb : (NOP, None),
    0x38 : (NOP, None),
    0x30 : (NOP, None),
    0x28 : (NOP, None),
    0x18 : (NOP, None),
}

def get_class(data, addr):
    inst_class, args = opdict[data[0]]
    if args == None:
        inst = inst_class()
    elif len(args) <= inst_class.getWidth() - 1:
        inst = inst_class(*args, int.from_bytes(data[1:inst_class.getWidth()], 'little'))
    else:
        inst = inst_class(*args)
    return inst, inst_class

def disas(data, addr):
    inst, inst_class = get_class(data, addr)
    return (inst.getTokens(addr), inst_class.getWidth())

def branch_info(data, addr, info):
    inst, inst_class = get_class(data, addr)
    if hasattr(inst_class, 'getBranch'):
        return inst.getBranch(info, addr)
    return info
